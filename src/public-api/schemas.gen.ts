// This file is auto-generated by generate-schema-types.ts

import z from "zod";

// v1.catalog.companies.{companyId}.get.ts
export const V1CatalogCompaniesCompanyidGetSchema = {
  inputSchema: {
    companyId: z.string().uuid(),
  },

  outputSchema: {
    id: z.string().uuid(),
    name: z.string(),
    legalName: z.string(),
    domain: z.string(),
    url: z.string().nullable().optional(),
    description: z.string(),
    discontinued: z
      .boolean()
      .describe(
        "If false, indicates that the company is active as a brand, even if acquired or merged with another company",
      ),
    icon: z.string().nullable().describe("The logo of the company.").optional(),
    fiscalYearEnd: z
      .string()
      .nullable()
      .describe("The fiscal year end for the company")
      .optional(),
    stockSymbols: z
      .array(
        z.object({
          symbol: z
            .string()
            .describe("The stock market symbol for the company"),
          exchange: z
            .string()
            .describe("The stock market exchange for this stock symbol"),
        }),
      )
      .describe("Array of public stock market symbols for the company")
      .optional(),
    category: z
      .object({
        id: z.string().uuid().describe("Unique identifier for the category"),
        name: z.string().describe("Name of the category"),
        description: z.string().describe("Description of the category"),
        parentCategoryId: z
          .string()
          .uuid()
          .nullable()
          .describe("ID of the parent category")
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
      })
      .optional(),
    productFamilies: z.array(
      z.object({
        id: z.string().uuid().describe("The ID of the product"),
        name: z.string().describe("The name of the product"),
        defaultPriceRange: z
          .object({
            min: z.number(),
            max: z.number(),
            currency: z
              .string()
              .describe("Currency of the default price range"),
          })
          .describe(
            "Range of prices products in this product family typically sell at",
          )
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
      }),
    ),
    products: z.array(
      z.object({
        id: z.string().uuid().describe("The ID of the product"),
        productFamilyId: z
          .string()
          .uuid()
          .nullable()
          .describe("ID of the product family this product is a part of")
          .optional(),
        name: z.string().describe("The name of the product"),
        description: z
          .string()
          .nullable()
          .describe("The description of the product")
          .optional(),
        icon: z
          .string()
          .nullable()
          .describe("The icon of the product")
          .optional(),
        url: z.string().nullable().describe("URL of the product").optional(),
        defaultPrice: z
          .number()
          .describe("The typical price of the product")
          .optional(),
        currency: z
          .string()
          .describe("Currency of the default price")
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
      }),
    ),
    defaultPriceRange: z
      .object({
        min: z.number(),
        max: z.number(),
        currency: z.string().describe("Currency of the default price range"),
      })
      .describe(
        "Range of prices products in this product family typically sell at",
      )
      .optional(),
    learningDataSamples: z.array(
      z.object({
        id: z.string().uuid(),
        startDate: z.string().datetime({ offset: true }),
        termMonths: z.number(),
        negotiatedPrice: z.number(),
        productNames: z.array(z.string()),
        primaryDimensionName: z.string(),
        primaryDimensionValue: z.number(),
        numberOfOtherDimensions: z.number(),
      }),
    ),
    lastUpdatedAt: z
      .string()
      .datetime({ offset: true })
      .describe("Date and time when this record was last updated"),
    competitors: z.array(
      z.object({
        id: z.string().uuid(),
        name: z.string(),
        domain: z.string(),
        icon: z
          .string()
          .nullable()
          .describe("The logo of the company.")
          .optional(),
      }),
    ),
  },
} as const;

// v1.scope.post.ts
export const V1ScopePostSchema = {
  inputSchema: {
    previousScopeId: z
      .string()
      .uuid()
      .nullable()
      .describe("Id of the previous scope this replaced")
      .optional(),
    scopeTerms: z
      .array(
        z.object({
          termLength: z.number().int().describe("Length of the term in months"),
          purchaseType: z
            .enum(["new_purchase", "renewal"])
            .describe("Whether the scope is a new purchase or a renewal."),
          autoRenew: z
            .boolean()
            .nullable()
            .describe("Whether the scope has a auto-renewal clause or not")
            .optional(),
          startDate: z.coerce
            .date()
            .nullable()
            .describe("Start date of the scope")
            .optional(),
          endDate: z.coerce
            .date()
            .nullable()
            .describe("End date of the scope")
            .optional(),
          listPrice: z
            .number()
            .nullable()
            .describe("List price of the scope")
            .optional(),
          discount: z
            .number()
            .nullable()
            .describe("Discount on the list price")
            .optional(),
          finalPrice: z
            .number()
            .nullable()
            .describe("Final price of the scope after discount")
            .optional(),
        }),
      )
      .min(1)
      .describe("Terms of purchase that apply to the whole scope"),
    productTerms: z
      .array(
        z.object({
          productId: z
            .string()
            .uuid()
            .describe("Id of the product the term applies to."),
          pricingDimensions: z
            .array(
              z.object({
                id: z.string().uuid().describe("Dimension ID"),
                value: z.number().describe("Value for this dimension"),
              }),
            )
            .min(1)
            .describe("Dimensions that impact the price of the product"),
          startDate: z.coerce
            .date()
            .nullable()
            .describe("Product specific start date")
            .optional(),
          endDate: z.coerce
            .date()
            .nullable()
            .describe("Product specific end date ")
            .optional(),
          listPrice: z
            .number()
            .nullable()
            .describe("Product specific list price")
            .optional(),
          discount: z
            .number()
            .nullable()
            .describe("Product specific discount ")
            .optional(),
          finalPrice: z
            .number()
            .nullable()
            .describe(
              "Product specific final price after applying discount on product list price",
            )
            .optional(),
        }),
      )
      .min(1)
      .describe(
        "Terms of purchase that apply to specific products, including the dimension values for each product",
      ),
  },

  outputSchema: {
    id: z.string().uuid().describe("ID of the scope"),
    source: z
      .enum(["manual", "document"])
      .describe(
        "Type of data source for this scope, can be either 'manual' or 'document'",
      ),
    createdOn: z
      .string()
      .datetime({ offset: true })
      .describe("Date and time the scope was created"),
    previousScopeId: z
      .string()
      .uuid()
      .nullable()
      .describe("ID of the previous scope to this scope (if any)")
      .optional(),
    nextScopeId: z
      .string()
      .uuid()
      .nullable()
      .describe("ID of the next scope to this scope (if any)")
      .optional(),
    documentProcessing: z
      .object({
        status: z
          .enum(["pending", "processing", "completed", "failed"])
          .describe("Current status of document processing"),
        filename: z.string().describe("Original filename of the document"),
        documentType: z
          .enum(["order_form", "contract", "other"])
          .describe("Detected document type"),
        mimeType: z.string().describe("MIME type of the document"),
        error: z
          .string()
          .nullable()
          .describe("Error message if processing failed")
          .optional(),
        updatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("When the processing status was last updated"),
      })
      .nullable()
      .describe("Document processing details, when relevant")
      .optional(),
    scopeTerms: z
      .array(
        z.object({
          termLength: z.number().int().describe("Length of the term in months"),
          purchaseType: z
            .enum(["new_purchase", "renewal"])
            .describe("Whether the scope is a new purchase or a renewal."),
          listPrice: z
            .number()
            .nullable()
            .describe("List price of the scope")
            .optional(),
          discount: z
            .number()
            .nullable()
            .describe("Discount on the list price")
            .optional(),
          finalPrice: z
            .number()
            .nullable()
            .describe("Final price of the scope after discount")
            .optional(),
        }),
      )
      .describe("Terms of purchase that apply to the whole scope"),
    productTerms: z
      .array(
        z.object({
          productId: z.string().uuid().describe("Product ID"),
          productName: z.string().describe("Name of the product"),
          productFamilyId: z
            .string()
            .uuid()
            .nullable()
            .describe("ID of the product family")
            .optional(),
          description: z
            .string()
            .nullable()
            .describe("Product description")
            .optional(),
          icon: z
            .string()
            .nullable()
            .describe("Icon of the product")
            .optional(),
          url: z.string().nullable().describe("URL of the product").optional(),
          pricingDimensions: z
            .array(
              z.object({
                id: z.string().uuid().describe("ID of the dimension"),
                name: z.string().describe("Name of the dimension"),
                description: z
                  .string()
                  .describe("Description of the dimension")
                  .optional(),
                value: z.number().describe("Value of the dimension").optional(),
              }),
            )
            .describe("Dimensions that impact the price of the product"),
          includedFeatures: z
            .array(
              z.object({
                id: z.string().uuid().describe("ID of the feature"),
                name: z.string().describe("Name of the feature"),
                description: z
                  .string()
                  .describe("Description of the feature")
                  .optional(),
              }),
            )
            .describe(
              "Add-on features generally included at no additional cost",
            ),
          listPrice: z.number().nullable().optional(),
          discount: z.number().nullable().optional(),
          finalPrice: z.number().nullable().optional(),
        }),
      )
      .describe(
        "Terms of purchase that apply to specific products, including the dimension values for each product",
      ),
  },
} as const;

// v1.scope.from-document.post.ts
export const V1ScopeFromDocumentPostSchema = {
  outputSchema: {
    scopeId: z.string().uuid().describe("ID of the created scope"),
  },
} as const;

// v1.pricing.advanced.{scopeId}.get.ts
export const V1PricingAdvancedScopeidGetSchema = {
  inputSchema: {
    scopeId: z.string().uuid(),
  },

  outputSchema: {
    estimate: z
      .object({
        percentile10: z.number().describe("10th percentile price estimate"),
        percentile15: z.number().describe("15th percentile price estimate"),
        percentile20: z.number().describe("20th percentile price estimate"),
        percentile25: z.number().describe("25th percentile price estimate"),
        percentile30: z.number().describe("30th percentile price estimate"),
        percentile35: z.number().describe("35th percentile price estimate"),
        percentile40: z.number().describe("40th percentile price estimate"),
        percentile45: z.number().describe("45th percentile price estimate"),
        percentile50: z
          .number()
          .describe("50th percentile price estimate (median)"),
        percentile55: z.number().describe("55th percentile price estimate"),
        percentile60: z.number().describe("60th percentile price estimate"),
        percentile65: z.number().describe("65th percentile price estimate"),
        percentile70: z.number().describe("70th percentile price estimate"),
        percentile75: z.number().describe("75th percentile price estimate"),
        percentile80: z.number().describe("80th percentile price estimate"),
        percentile85: z.number().describe("85th percentile price estimate"),
        percentile90: z.number().describe("90th percentile price estimate"),
      })
      .describe("Price estimate distribution at 5 percentile increments"),
    productEstimates: z
      .array(
        z.record(z.any()).and(
          z.any().superRefine((x, ctx) => {
            const schemas = [
              z
                .object({
                  status: z.literal("success"),
                  defaulted: z
                    .boolean()
                    .describe(
                      "Whether the product estimate was defaulted to a fallback",
                    ),
                  estimate: z
                    .object({
                      percentile10: z
                        .number()
                        .describe("10th percentile price estimate"),
                      percentile15: z
                        .number()
                        .describe("15th percentile price estimate"),
                      percentile20: z
                        .number()
                        .describe("20th percentile price estimate"),
                      percentile25: z
                        .number()
                        .describe("25th percentile price estimate"),
                      percentile30: z
                        .number()
                        .describe("30th percentile price estimate"),
                      percentile35: z
                        .number()
                        .describe("35th percentile price estimate"),
                      percentile40: z
                        .number()
                        .describe("40th percentile price estimate"),
                      percentile45: z
                        .number()
                        .describe("45th percentile price estimate"),
                      percentile50: z
                        .number()
                        .describe("50th percentile price estimate (median)"),
                      percentile55: z
                        .number()
                        .describe("55th percentile price estimate"),
                      percentile60: z
                        .number()
                        .describe("60th percentile price estimate"),
                      percentile65: z
                        .number()
                        .describe("65th percentile price estimate"),
                      percentile70: z
                        .number()
                        .describe("70th percentile price estimate"),
                      percentile75: z
                        .number()
                        .describe("75th percentile price estimate"),
                      percentile80: z
                        .number()
                        .describe("80th percentile price estimate"),
                      percentile85: z
                        .number()
                        .describe("85th percentile price estimate"),
                      percentile90: z
                        .number()
                        .describe("90th percentile price estimate"),
                    })
                    .describe(
                      "Price estimate distribution at 5 percentile increments",
                    ),
                  name: z.string().describe("Name of the product"),
                  productId: z.string().uuid().describe("ID of the product"),
                })
                .strict(),
              z
                .object({
                  status: z.literal("error"),
                  code: z.enum(["pricing_failed", "validation_failed"]),
                  defaulted: z
                    .boolean()
                    .describe(
                      "Whether the product estimate was defaulted to a fallback, that then failed",
                    ),
                  message: z.string().describe("Error message"),
                  name: z.string().describe("Name of the product"),
                  productId: z.string().uuid().describe("ID of the product"),
                })
                .strict(),
            ];
            const errors = schemas.reduce<z.ZodError[]>(
              (errors, schema) =>
                ((result) =>
                  result.error ? [...errors, result.error] : errors)(
                  schema.safeParse(x),
                ),
              [],
            );
            if (schemas.length - errors.length !== 1) {
              ctx.addIssue({
                path: ctx.path,
                code: "invalid_union",
                unionErrors: errors,
                message: "Invalid input: Should pass single schema",
              });
            }
          }),
        ),
      )
      .describe("Product level price estimate distributions"),
    currency: z.string().describe("Currency code (ISO 4217)"),
    timestamp: z
      .string()
      .datetime({ offset: true })
      .describe("Timestamp when this estimate was generated"),
  },
} as const;

// v1.pricing.basic.{scopeId}.get.ts
export const V1PricingBasicScopeidGetSchema = {
  inputSchema: {
    scopeId: z.string().uuid(),
  },

  outputSchema: {
    estimate: z.object({
      percentile25: z.number().describe("25th percentile price estimate"),
      percentile50: z
        .number()
        .describe("50th percentile price estimate (median)"),
      percentile75: z.number().describe("75th percentile price estimate"),
    }),
    currency: z.string().describe("Currency code (ISO 4217)"),
    timestamp: z
      .string()
      .datetime({ offset: true })
      .describe("Timestamp when this estimate was generated"),
  },
} as const;

// v1.catalog.products.{productId}.get.ts
export const V1CatalogProductsProductidGetSchema = {
  inputSchema: {
    productId: z.string().uuid(),
  },

  outputSchema: {
    defaultPrice: z
      .number()
      .describe("The typical price of the product")
      .optional(),
    company: z.object({
      id: z.string().uuid(),
      name: z.string(),
      legalName: z.string(),
      domain: z.string(),
    }),

    id: z.string().uuid().describe("The ID of the product"),
    productFamilyId: z
      .string()
      .uuid()
      .nullable()
      .describe("ID of the product family this product is a part of")
      .optional(),
    name: z.string().describe("The name of the product"),
    description: z.string().describe("The description of the product"),
    icon: z.string().nullable().describe("The icon of the product").optional(),
    url: z.string().nullable().describe("The URL of the product").optional(),
    pricingDimensions: z.array(
      z.object({
        id: z.string().uuid().describe("The ID of the dimension."),
        name: z.string().describe("The name of the dimension."),
        description: z
          .string()
          .nullable()
          .describe("The description of the dimension."),
        priceImpactKnown: z
          .boolean()
          .describe(
            "whether the impact of this dimension on price is clearly known or not",
          ),
        formField: z.record(z.any()).and(
          z.any().superRefine((x, ctx) => {
            const schemas = [
              z
                .object({
                  type: z.literal("checkbox"),
                  label: z.string(),
                  readonly: z.boolean().default(false),
                  required: z.boolean().default(false),
                  defaultValue: z.boolean().nullable().optional(),
                  value: z.number().default(1),
                })
                .strict(),
              z
                .object({
                  type: z.literal("number"),
                  label: z.string(),
                  readonly: z.boolean().default(false),
                  required: z.boolean().default(false),
                  defaultValue: z.number().nullable().optional(),
                  min: z
                    .number()
                    .nullable()
                    .describe("Minimum allowed value")
                    .optional(),
                  max: z
                    .number()
                    .nullable()
                    .describe("Maximum allowed value")
                    .optional(),
                  step: z
                    .number()
                    .nullable()
                    .describe("Step increment for number input")
                    .optional(),
                })
                .strict(),
              z
                .object({
                  type: z.literal("select"),
                  label: z.string(),
                  readonly: z.boolean().default(false),
                  required: z.boolean().default(false),
                  defaultValue: z.string().nullable().optional(),
                  options: z
                    .array(
                      z
                        .object({ label: z.string(), value: z.string() })
                        .strict(),
                    )
                    .describe("Available options for select field"),
                })
                .strict(),
            ];
            const errors = schemas.reduce<z.ZodError[]>(
              (errors, schema) =>
                ((result) =>
                  result.error ? [...errors, result.error] : errors)(
                  schema.safeParse(x),
                ),
              [],
            );
            if (schemas.length - errors.length !== 1) {
              ctx.addIssue({
                path: ctx.path,
                code: "invalid_union",
                unionErrors: errors,
                message: "Invalid input: Should pass single schema",
              });
            }
          }),
        ),
        dependsOn: z.object({
          dependsOnDimensionId: z
            .string()
            .uuid()
            .nullable()
            .describe("The ID of the dimension that this dimension depends on")
            .optional(),
          dependency: z
            .enum(["quantity", "inclusion"])
            .nullable()
            .describe(
              "The type of dependency. Inclusion means that the dimension is dependent on the inclusion of another dimension. Quantity means the dimensions quantity is equal to the quantity of the other dimension.",
            )
            .optional(),
        }),
      }),
    ),
    includedFeatures: z.array(
      z.object({
        id: z.string().uuid().describe("Feature ID"),
        name: z.string().describe("Feature name"),
        description: z.string().describe("Feature description"),
      }),
    ),
    currency: z.string().describe("Currency of the default price").optional(),
    lastUpdatedAt: z
      .string()
      .datetime({ offset: true })
      .describe("Date and time when this record was last updated"),
    competitors: z.array(
      z.object({
        companyId: z.string().uuid(),
        companyName: z.string(),
        domain: z.string(),
        companyIcon: z.string().optional(),
        productId: z.string().uuid(),
        defaultPrice: z
          .number()
          .describe("The typical price of the product")
          .optional(),
        productIcon: z.string().optional(),
        productUrl: z.string().optional(),
        productName: z.string(),
        pricingDimensions: z.array(
          z.object({
            id: z.string().uuid().describe("The ID of the dimension."),
            name: z.string().describe("The name of the dimension."),
            description: z
              .string()
              .nullable()
              .describe("The description of the dimension."),
            priceImpactKnown: z
              .boolean()
              .describe(
                "whether the impact of this dimension on price is clearly known or not",
              ),
            formField: z.record(z.any()).and(
              z.any().superRefine((x, ctx) => {
                const schemas = [
                  z
                    .object({
                      type: z.literal("checkbox"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.boolean().nullable().optional(),
                      value: z.number().default(1),
                    })
                    .strict(),
                  z
                    .object({
                      type: z.literal("number"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.number().nullable().optional(),
                      min: z
                        .number()
                        .nullable()
                        .describe("Minimum allowed value")
                        .optional(),
                      max: z
                        .number()
                        .nullable()
                        .describe("Maximum allowed value")
                        .optional(),
                      step: z
                        .number()
                        .nullable()
                        .describe("Step increment for number input")
                        .optional(),
                    })
                    .strict(),
                  z
                    .object({
                      type: z.literal("select"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.string().nullable().optional(),
                      options: z
                        .array(
                          z
                            .object({ label: z.string(), value: z.string() })
                            .strict(),
                        )
                        .describe("Available options for select field"),
                    })
                    .strict(),
                ];
                const errors = schemas.reduce<z.ZodError[]>(
                  (errors, schema) =>
                    ((result) =>
                      result.error ? [...errors, result.error] : errors)(
                      schema.safeParse(x),
                    ),
                  [],
                );
                if (schemas.length - errors.length !== 1) {
                  ctx.addIssue({
                    path: ctx.path,
                    code: "invalid_union",
                    unionErrors: errors,
                    message: "Invalid input: Should pass single schema",
                  });
                }
              }),
            ),
            dependsOn: z.object({
              dependsOnDimensionId: z
                .string()
                .uuid()
                .nullable()
                .describe(
                  "The ID of the dimension that this dimension depends on",
                )
                .optional(),
              dependency: z
                .enum(["quantity", "inclusion"])
                .nullable()
                .describe(
                  "The type of dependency. Inclusion means that the dimension is dependent on the inclusion of another dimension. Quantity means the dimensions quantity is equal to the quantity of the other dimension.",
                )
                .optional(),
            }),
          }),
        ),
        includedFeatures: z.array(
          z.object({
            id: z.string().uuid().describe("Feature ID"),
            name: z.string().describe("Feature name"),
            description: z.string().describe("Feature description"),
          }),
        ),
      }),
    ),
  },
} as const;

// v1.catalog.product-families.{productFamilyId}.get.ts
export const V1CatalogProductFamiliesProductfamilyidGetSchema = {
  inputSchema: {
    productFamilyId: z.string().uuid(),
  },

  outputSchema: {
    id: z.string().uuid().describe("The ID of the product family"),
    name: z.string().describe("The name of the product family"),
    defaultPriceRange: z
      .object({
        min: z.number(),
        max: z.number(),
        currency: z.string().describe("Currency of the default price range"),
      })
      .describe(
        "Range of prices products in this product family typically sell at",
      )
      .optional(),
    lastUpdatedAt: z
      .string()
      .datetime({ offset: true })
      .describe("Date and time when this record was last updated"),
    products: z
      .array(
        z.object({
          id: z.string().uuid().describe("The ID of the product"),
          productFamilyId: z
            .string()
            .uuid()
            .nullable()
            .describe("ID of the product family this product is a part of")
            .optional(),
          name: z.string().describe("The name of the product"),
          description: z
            .string()
            .nullable()
            .describe("The description of the product")
            .optional(),
          icon: z
            .string()
            .nullable()
            .describe("The icon of the product")
            .optional(),
          url: z.string().nullable().describe("URL of the product").optional(),
          defaultPrice: z
            .number()
            .describe("The typical price of the product")
            .optional(),
          currency: z
            .string()
            .describe("Currency of the default price")
            .optional(),
          lastUpdatedAt: z
            .string()
            .datetime({ offset: true })
            .describe("Date and time when this record was last updated"),
        }),
      )
      .optional(),
  },
} as const;

// v1.scope.{scopeId}.get.ts
export const V1ScopeScopeidGetSchema = {
  inputSchema: {
    scopeId: z.string().uuid(),
  },

  outputSchema: {
    id: z.string().uuid().describe("ID of the scope"),
    source: z
      .enum(["manual", "document"])
      .describe(
        "Type of data source for this scope, can be either 'manual' or 'document'",
      ),
    createdOn: z
      .string()
      .datetime({ offset: true })
      .describe("Date and time the scope was created"),
    previousScopeId: z
      .string()
      .uuid()
      .nullable()
      .describe("ID of the previous scope to this scope (if any)")
      .optional(),
    nextScopeId: z
      .string()
      .uuid()
      .nullable()
      .describe("ID of the next scope to this scope (if any)")
      .optional(),
    documentProcessing: z
      .object({
        status: z
          .enum(["pending", "processing", "completed", "failed"])
          .describe("Current status of document processing"),
        filename: z.string().describe("Original filename of the document"),
        documentType: z
          .enum(["order_form", "contract", "other"])
          .describe("Detected document type"),
        mimeType: z.string().describe("MIME type of the document"),
        error: z
          .string()
          .nullable()
          .describe("Error message if processing failed")
          .optional(),
        updatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("When the processing status was last updated"),
      })
      .nullable()
      .describe("Document processing details, when relevant")
      .optional(),
    scopeTerms: z
      .array(
        z.object({
          termLength: z.number().int().describe("Length of the term in months"),
          purchaseType: z
            .enum(["new_purchase", "renewal"])
            .describe("Whether the scope is a new purchase or a renewal."),
          listPrice: z
            .number()
            .nullable()
            .describe("List price of the scope")
            .optional(),
          discount: z
            .number()
            .nullable()
            .describe("Discount on the list price")
            .optional(),
          finalPrice: z
            .number()
            .nullable()
            .describe("Final price of the scope after discount")
            .optional(),
        }),
      )
      .describe("Terms of purchase that apply to the whole scope"),
    productTerms: z
      .array(
        z.object({
          productId: z.string().uuid().describe("Product ID"),
          productName: z.string().describe("Name of the product"),
          productFamilyId: z
            .string()
            .uuid()
            .nullable()
            .describe("ID of the product family")
            .optional(),
          description: z
            .string()
            .nullable()
            .describe("Product description")
            .optional(),
          icon: z
            .string()
            .nullable()
            .describe("Icon of the product")
            .optional(),
          url: z.string().nullable().describe("URL of the product").optional(),
          pricingDimensions: z
            .array(
              z.object({
                id: z.string().uuid().describe("ID of the dimension"),
                name: z.string().describe("Name of the dimension"),
                description: z
                  .string()
                  .describe("Description of the dimension")
                  .optional(),
                value: z.number().describe("Value of the dimension").optional(),
              }),
            )
            .describe("Dimensions that impact the price of the product"),
          includedFeatures: z
            .array(
              z.object({
                id: z.string().uuid().describe("ID of the feature"),
                name: z.string().describe("Name of the feature"),
                description: z
                  .string()
                  .describe("Description of the feature")
                  .optional(),
              }),
            )
            .describe(
              "Add-on features generally included at no additional cost",
            ),
          listPrice: z.number().nullable().optional(),
          discount: z.number().nullable().optional(),
          finalPrice: z.number().nullable().optional(),
        }),
      )
      .describe(
        "Terms of purchase that apply to specific products, including the dimension values for each product",
      ),
  },
} as const;

// v1.catalog.categories.get.ts
export const V1CatalogCategoriesGetSchema = {
  inputSchema: {
    limit: z.coerce.number().int().gte(1).lte(100).default(10),
    offset: z.coerce.number().int().gte(0).default(0),
    parentCategoryId: z.string().uuid().optional(),
    sortBy: z.literal("name").default("name"),
    sortOrder: z.enum(["asc", "desc"]).default("asc"),
  },

  outputSchema: {
    data: z.array(
      z.object({
        id: z.string().uuid().describe("Unique identifier for the category"),
        name: z.string().describe("Name of the category"),
        description: z.string().describe("Description of the category"),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
        childCategories: z
          .array(
            z.object({
              id: z
                .string()
                .uuid()
                .describe("Unique identifier for the category"),
              name: z.string().describe("Name of the category"),
              description: z.string().describe("Description of the category"),
              lastUpdatedAt: z
                .string()
                .datetime({ offset: true })
                .describe("Date and time when this record was last updated"),
            }),
          )
          .describe("Array of child categories")
          .default([]),
      }),
    ),
    pagination: z.object({
      total: z.number().int(),
      limit: z.number().int(),
      offset: z.number().int(),
    }),
  },
} as const;

// v1.catalog.companies.get.ts
export const V1CatalogCompaniesGetSchema = {
  inputSchema: {
    name: z.string().optional(),
    domain: z.string().optional(),
    categoryId: z.string().uuid().optional(),
    limit: z.coerce.number().int().gte(1).lte(100).default(10),
    offset: z.coerce.number().int().gte(0).default(0),
    sortBy: z.literal("name").default("name"),
    sortOrder: z.enum(["asc", "desc"]).default("asc"),
    ids: z
      .string()
      .transform((str) => str.split(","))
      .pipe(z.array(z.string().uuid()).max(30))
      .optional(),
  },

  outputSchema: {
    data: z.array(
      z.object({
        id: z.string().uuid(),
        name: z.string(),
        legalName: z.string(),
        domain: z.string(),
        url: z.string().nullable().optional(),
        description: z.string(),
        discontinued: z
          .boolean()
          .describe(
            "If false, indicates that the company is active as a brand, even if acquired or merged with another company",
          ),
        icon: z
          .string()
          .nullable()
          .describe("The logo of the company.")
          .optional(),
        fiscalYearEnd: z
          .string()
          .nullable()
          .describe("The fiscal year end for the company")
          .optional(),
        stockSymbols: z
          .array(
            z.object({
              symbol: z
                .string()
                .describe("The stock market symbol for the company"),
              exchange: z
                .string()
                .describe("The stock market exchange for this stock symbol"),
            }),
          )
          .describe("Array of public stock market symbols for the company")
          .optional(),
        category: z
          .object({
            id: z
              .string()
              .uuid()
              .describe("Unique identifier for the category"),
            name: z.string().describe("Name of the category"),
            description: z.string().describe("Description of the category"),
            parentCategoryId: z
              .string()
              .uuid()
              .nullable()
              .describe("ID of the parent category")
              .optional(),
            lastUpdatedAt: z
              .string()
              .datetime({ offset: true })
              .describe("Date and time when this record was last updated"),
          })
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
        competitors: z
          .array(
            z.object({
              id: z.string().uuid(),
              name: z.string(),
              domain: z.string(),
              icon: z
                .string()
                .nullable()
                .describe("The logo of the company.")
                .optional(),
            }),
          )
          .optional(),
      }),
    ),
    pagination: z.object({
      total: z.number().int(),
      limit: z.number().int(),
      offset: z.number().int(),
    }),
  },
} as const;

// v1.catalog.companies.{companyId}.product-families.get.ts
export const V1CatalogCompaniesCompanyidProductFamiliesGetSchema = {
  inputSchema: {
    companyId: z.string().uuid(),
    ids: z
      .string()
      .transform((str) => str.split(","))
      .pipe(z.array(z.string().uuid()).max(30))
      .optional(),
    limit: z.coerce.number().int().gte(1).lte(100).default(10),
    offset: z.coerce.number().int().gte(0).default(0),
    sortBy: z.enum(["name", "sortOrder"]).default("sortOrder"),
    sortOrder: z.enum(["asc", "desc"]).default("asc"),
  },

  outputSchema: {
    data: z.array(
      z.object({
        id: z.string().uuid().describe("The ID of the product family"),
        name: z.string().describe("The name of the product family"),
        defaultPriceRange: z
          .object({
            min: z.number(),
            max: z.number(),
            currency: z
              .string()
              .describe("Currency of the default price range"),
          })
          .describe(
            "Range of prices products in this product family typically sell at",
          )
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
        products: z
          .array(
            z.object({
              id: z.string().uuid().describe("The ID of the product"),
              productFamilyId: z
                .string()
                .uuid()
                .nullable()
                .describe("ID of the product family this product is a part of")
                .optional(),
              name: z.string().describe("The name of the product"),
              description: z
                .string()
                .nullable()
                .describe("The description of the product")
                .optional(),
              icon: z
                .string()
                .nullable()
                .describe("The icon of the product")
                .optional(),
              url: z
                .string()
                .nullable()
                .describe("URL of the product")
                .optional(),
              defaultPrice: z
                .number()
                .describe("The typical price of the product")
                .optional(),
              currency: z
                .string()
                .describe("Currency of the default price")
                .optional(),
              lastUpdatedAt: z
                .string()
                .datetime({ offset: true })
                .describe("Date and time when this record was last updated"),
            }),
          )
          .optional(),
      }),
    ),
    pagination: z.object({
      total: z.number().int(),
      limit: z.number().int(),
      offset: z.number().int(),
    }),
  },
} as const;

// v1.catalog.companies.{companyId}.products.get.ts
export const V1CatalogCompaniesCompanyidProductsGetSchema = {
  inputSchema: {
    companyId: z.string().uuid(),
    ids: z
      .string()
      .transform((str) => str.split(","))
      .pipe(z.array(z.string().uuid()).max(30))
      .optional(),
    productFamilyId: z.string().uuid().optional(),
    limit: z.coerce.number().int().gte(1).lte(100).default(10),
    offset: z.coerce.number().int().gte(0).default(0),
    sortBy: z.enum(["name", "sortOrder"]).default("sortOrder"),
    sortOrder: z.enum(["asc", "desc"]).default("asc"),
  },

  outputSchema: {
    data: z.array(
      z.object({
        id: z.string().uuid().describe("The ID of the product"),
        productFamilyId: z
          .string()
          .uuid()
          .nullable()
          .describe("ID of the product family this product is a part of")
          .optional(),
        name: z.string().describe("The name of the product"),
        description: z.string().describe("The description of the product"),
        icon: z
          .string()
          .nullable()
          .describe("The icon of the product")
          .optional(),
        url: z
          .string()
          .nullable()
          .describe("The URL of the product")
          .optional(),
        pricingDimensions: z.array(
          z.object({
            id: z.string().uuid().describe("The ID of the dimension."),
            name: z.string().describe("The name of the dimension."),
            description: z
              .string()
              .nullable()
              .describe("The description of the dimension."),
            priceImpactKnown: z
              .boolean()
              .describe(
                "whether the impact of this dimension on price is clearly known or not",
              ),
            formField: z.record(z.any()).and(
              z.any().superRefine((x, ctx) => {
                const schemas = [
                  z
                    .object({
                      type: z.literal("checkbox"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.boolean().nullable().optional(),
                      value: z.number().default(1),
                    })
                    .strict(),
                  z
                    .object({
                      type: z.literal("number"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.number().nullable().optional(),
                      min: z
                        .number()
                        .nullable()
                        .describe("Minimum allowed value")
                        .optional(),
                      max: z
                        .number()
                        .nullable()
                        .describe("Maximum allowed value")
                        .optional(),
                      step: z
                        .number()
                        .nullable()
                        .describe("Step increment for number input")
                        .optional(),
                    })
                    .strict(),
                  z
                    .object({
                      type: z.literal("select"),
                      label: z.string(),
                      readonly: z.boolean().default(false),
                      required: z.boolean().default(false),
                      defaultValue: z.string().nullable().optional(),
                      options: z
                        .array(
                          z
                            .object({ label: z.string(), value: z.string() })
                            .strict(),
                        )
                        .describe("Available options for select field"),
                    })
                    .strict(),
                ];
                const errors = schemas.reduce<z.ZodError[]>(
                  (errors, schema) =>
                    ((result) =>
                      result.error ? [...errors, result.error] : errors)(
                      schema.safeParse(x),
                    ),
                  [],
                );
                if (schemas.length - errors.length !== 1) {
                  ctx.addIssue({
                    path: ctx.path,
                    code: "invalid_union",
                    unionErrors: errors,
                    message: "Invalid input: Should pass single schema",
                  });
                }
              }),
            ),
            dependsOn: z.object({
              dependsOnDimensionId: z
                .string()
                .uuid()
                .nullable()
                .describe(
                  "The ID of the dimension that this dimension depends on",
                )
                .optional(),
              dependency: z
                .enum(["quantity", "inclusion"])
                .nullable()
                .describe(
                  "The type of dependency. Inclusion means that the dimension is dependent on the inclusion of another dimension. Quantity means the dimensions quantity is equal to the quantity of the other dimension.",
                )
                .optional(),
            }),
          }),
        ),
        includedFeatures: z.array(
          z.object({
            id: z.string().uuid().describe("Feature ID"),
            name: z.string().describe("Feature name"),
            description: z.string().describe("Feature description"),
          }),
        ),
        currency: z
          .string()
          .describe("Currency of the default price")
          .optional(),
        lastUpdatedAt: z
          .string()
          .datetime({ offset: true })
          .describe("Date and time when this record was last updated"),
        competitors: z.array(
          z.object({
            companyId: z.string().uuid(),
            companyName: z.string(),
            domain: z.string(),
            companyIcon: z.string().optional(),
            productId: z.string().uuid(),
            defaultPrice: z
              .number()
              .describe("The typical price of the product")
              .optional(),
            productIcon: z.string().optional(),
            productUrl: z.string().optional(),
            productName: z.string(),
            pricingDimensions: z.array(
              z.object({
                id: z.string().uuid().describe("The ID of the dimension."),
                name: z.string().describe("The name of the dimension."),
                description: z
                  .string()
                  .nullable()
                  .describe("The description of the dimension."),
                priceImpactKnown: z
                  .boolean()
                  .describe(
                    "whether the impact of this dimension on price is clearly known or not",
                  ),
                formField: z.record(z.any()).and(
                  z.any().superRefine((x, ctx) => {
                    const schemas = [
                      z
                        .object({
                          type: z.literal("checkbox"),
                          label: z.string(),
                          readonly: z.boolean().default(false),
                          required: z.boolean().default(false),
                          defaultValue: z.boolean().nullable().optional(),
                          value: z.number().default(1),
                        })
                        .strict(),
                      z
                        .object({
                          type: z.literal("number"),
                          label: z.string(),
                          readonly: z.boolean().default(false),
                          required: z.boolean().default(false),
                          defaultValue: z.number().nullable().optional(),
                          min: z
                            .number()
                            .nullable()
                            .describe("Minimum allowed value")
                            .optional(),
                          max: z
                            .number()
                            .nullable()
                            .describe("Maximum allowed value")
                            .optional(),
                          step: z
                            .number()
                            .nullable()
                            .describe("Step increment for number input")
                            .optional(),
                        })
                        .strict(),
                      z
                        .object({
                          type: z.literal("select"),
                          label: z.string(),
                          readonly: z.boolean().default(false),
                          required: z.boolean().default(false),
                          defaultValue: z.string().nullable().optional(),
                          options: z
                            .array(
                              z
                                .object({
                                  label: z.string(),
                                  value: z.string(),
                                })
                                .strict(),
                            )
                            .describe("Available options for select field"),
                        })
                        .strict(),
                    ];
                    const errors = schemas.reduce<z.ZodError[]>(
                      (errors, schema) =>
                        ((result) =>
                          result.error ? [...errors, result.error] : errors)(
                          schema.safeParse(x),
                        ),
                      [],
                    );
                    if (schemas.length - errors.length !== 1) {
                      ctx.addIssue({
                        path: ctx.path,
                        code: "invalid_union",
                        unionErrors: errors,
                        message: "Invalid input: Should pass single schema",
                      });
                    }
                  }),
                ),
                dependsOn: z.object({
                  dependsOnDimensionId: z
                    .string()
                    .uuid()
                    .nullable()
                    .describe(
                      "The ID of the dimension that this dimension depends on",
                    )
                    .optional(),
                  dependency: z
                    .enum(["quantity", "inclusion"])
                    .nullable()
                    .describe(
                      "The type of dependency. Inclusion means that the dimension is dependent on the inclusion of another dimension. Quantity means the dimensions quantity is equal to the quantity of the other dimension.",
                    )
                    .optional(),
                }),
              }),
            ),
            includedFeatures: z.array(
              z.object({
                id: z.string().uuid().describe("Feature ID"),
                name: z.string().describe("Feature name"),
                description: z.string().describe("Feature description"),
              }),
            ),
          }),
        ),
      }),
    ),
    pagination: z.object({
      total: z.number().int(),
      limit: z.number().int(),
      offset: z.number().int(),
    }),
  },
} as const;
